/**
 * Storage utility â€” single source of truth for all chrome.storage.local operations.
 *
 * Data shape in storage:
 * {
 *   groups: TabGroup[],
 *   sessions: Session[],
 *   settings: Settings
 * }
 *
 * TabGroup  { id, name, domain, color, createdAt, isAutoGenerated, tabs: SavedTab[] }
 * SavedTab  { id, url, title, favIconUrl, savedAt, tags: string[] }
 * Session   { id, savedAt, tabCount, groupIds: string[] }
 * Settings  { theme: "system"|"light"|"dark", removeAfterRestore?: boolean }
 */

const DEFAULT_DATA = {
  groups: [],
  sessions: [],
  settings: { theme: "system" },
};

/* ---------- helpers ---------- */

function generateId() {
  return crypto.randomUUID
    ? crypto.randomUUID()
    : Date.now().toString(36) + Math.random().toString(36).slice(2);
}

/* ---------- low-level read / write ---------- */

async function _read() {
  const data = await chrome.storage.local.get([
    "groups",
    "sessions",
    "settings",
  ]);
  return {
    groups: data.groups ?? DEFAULT_DATA.groups,
    sessions: data.sessions ?? DEFAULT_DATA.sessions,
    settings: data.settings ?? DEFAULT_DATA.settings,
  };
}

async function _write(partial) {
  await chrome.storage.local.set(partial);
}

/* ---------- groups ---------- */

async function getGroups() {
  const { groups } = await _read();
  return groups;
}

async function getGroupById(groupId) {
  const groups = await getGroups();
  return groups.find((g) => g.id === groupId) ?? null;
}

async function createGroup({ name, domain, color, isAutoGenerated = false }) {
  const groups = await getGroups();
  const group = {
    id: generateId(),
    name,
    domain: domain ?? null,
    color: color ?? "#6B7280",
    createdAt: Date.now(),
    isAutoGenerated,
    tabs: [],
  };
  groups.push(group);
  await _write({ groups });
  return group;
}

async function deleteGroup(groupId) {
  let groups = await getGroups();
  groups = groups.filter((g) => g.id !== groupId);
  await _write({ groups });
}

async function renameGroup(groupId, newName) {
  const groups = await getGroups();
  const group = groups.find((g) => g.id === groupId);
  if (group) {
    group.name = newName;
    await _write({ groups });
  }
}

/* ---------- tabs ---------- */

/**
 * Add tabs to storage. Each entry: { url, title, favIconUrl }.
 * Returns { saved: number, duplicates: number }.
 */
async function saveTabs(tabEntries, { groupResolver } = {}) {
  const { groups } = await _read();
  let saved = 0;
  let duplicates = 0;

  // Build a Set of all existing normalized URLs for duplicate detection
  const existingUrls = new Set();
  for (const g of groups) {
    for (const t of g.tabs) {
      existingUrls.add(normalizeUrl(t.url));
    }
  }

  for (const entry of tabEntries) {
    const normUrl = normalizeUrl(entry.url);

    // Duplicate check
    if (existingUrls.has(normUrl)) {
      duplicates++;
      continue;
    }

    // Resolve group
    let targetGroup;
    if (typeof groupResolver === "function") {
      targetGroup = groupResolver(entry, groups);
    }
    if (!targetGroup) {
      // fallback: find or create an "Ungrouped" group
      targetGroup = groups.find((g) => g.domain === "__ungrouped__");
      if (!targetGroup) {
        targetGroup = {
          id: generateId(),
          name: "Ungrouped",
          domain: "__ungrouped__",
          color: "#9CA3AF",
          createdAt: Date.now(),
          isAutoGenerated: true,
          tabs: [],
        };
        groups.push(targetGroup);
      }
    }

    const tab = {
      id: generateId(),
      url: entry.url,
      title: entry.title || entry.url,
      favIconUrl: entry.favIconUrl || "",
      savedAt: Date.now(),
      tags: [],
    };

    targetGroup.tabs.push(tab);
    existingUrls.add(normUrl);
    saved++;
  }

  await _write({ groups });
  return { saved, duplicates };
}

async function removeTab(groupId, tabId) {
  const groups = await getGroups();
  const group = groups.find((g) => g.id === groupId);
  if (group) {
    group.tabs = group.tabs.filter((t) => t.id !== tabId);
    // Remove group if empty and auto-generated
    if (group.tabs.length === 0 && group.isAutoGenerated) {
      const idx = groups.indexOf(group);
      groups.splice(idx, 1);
    }
    await _write({ groups });
  }
}

async function moveTab(tabId, fromGroupId, toGroupId) {
  const groups = await getGroups();
  const fromGroup = groups.find((g) => g.id === fromGroupId);
  const toGroup = groups.find((g) => g.id === toGroupId);
  if (!fromGroup || !toGroup) return;

  const tabIdx = fromGroup.tabs.findIndex((t) => t.id === tabId);
  if (tabIdx === -1) return;

  const [tab] = fromGroup.tabs.splice(tabIdx, 1);
  toGroup.tabs.push(tab);

  // Clean up empty auto-generated group
  if (fromGroup.tabs.length === 0 && fromGroup.isAutoGenerated) {
    const idx = groups.indexOf(fromGroup);
    groups.splice(idx, 1);
  }

  await _write({ groups });
}

/* ---------- sessions ---------- */

async function createSession(tabCount, groupIds) {
  const { sessions } = await _read();
  const session = {
    id: generateId(),
    savedAt: Date.now(),
    tabCount,
    groupIds,
  };
  sessions.unshift(session); // newest first
  // Keep only last 50 sessions
  if (sessions.length > 50) sessions.length = 50;
  await _write({ sessions });
  return session;
}

async function getSessions() {
  const { sessions } = await _read();
  return sessions;
}

/* ---------- search ---------- */

function searchTabs(groups, query) {
  const q = query.toLowerCase().trim();
  if (!q) return [];

  const results = [];
  for (const group of groups) {
    for (const tab of group.tabs) {
      const haystack =
        `${tab.title} ${tab.url} ${(tab.tags || []).join(" ")} ${group.name}`.toLowerCase();
      if (haystack.includes(q)) {
        results.push({ ...tab, groupId: group.id, groupName: group.name });
      }
    }
  }
  return results;
}

/* ---------- export / import ---------- */

async function exportData() {
  const data = await _read();
  return JSON.stringify(data, null, 2);
}

async function importData(jsonString, mode = "merge") {
  const incoming = JSON.parse(jsonString);
  if (!incoming.groups || !Array.isArray(incoming.groups)) {
    throw new Error("Invalid data format: missing groups array.");
  }

  if (mode === "replace") {
    await _write({
      groups: incoming.groups,
      sessions: incoming.sessions ?? [],
      settings: incoming.settings ?? DEFAULT_DATA.settings,
    });
  } else {
    // merge: add non-duplicate tabs from incoming
    const current = await _read();
    const existingUrls = new Set();
    for (const g of current.groups) {
      for (const t of g.tabs) existingUrls.add(normalizeUrl(t.url));
    }

    for (const inGroup of incoming.groups) {
      let matchingGroup = current.groups.find(
        (g) => g.domain && g.domain === inGroup.domain,
      );
      if (!matchingGroup) {
        matchingGroup = { ...inGroup, id: generateId(), tabs: [] };
        current.groups.push(matchingGroup);
      }
      for (const tab of inGroup.tabs) {
        if (!existingUrls.has(normalizeUrl(tab.url))) {
          matchingGroup.tabs.push({ ...tab, id: generateId() });
          existingUrls.add(normalizeUrl(tab.url));
        }
      }
    }

    await _write({ groups: current.groups });
  }
}

/* ---------- stats ---------- */

async function getTotalTabCount() {
  const groups = await getGroups();
  return groups.reduce((sum, g) => sum + g.tabs.length, 0);
}

/* ---------- URL normalization ---------- */

function normalizeUrl(url) {
  try {
    const u = new URL(url);
    // Strip fragment
    u.hash = "";
    // Strip trailing slash from pathname
    if (u.pathname.endsWith("/") && u.pathname.length > 1) {
      u.pathname = u.pathname.slice(0, -1);
    }
    // Sort query params
    u.searchParams.sort();
    return u.toString().toLowerCase();
  } catch {
    return url.toLowerCase().replace(/\/+$/, "");
  }
}

// Export for use in other modules (ES module or global depending on context)
if (typeof globalThis !== "undefined") {
  globalThis.ShelveStorage = {
    getGroups,
    getGroupById,
    createGroup,
    deleteGroup,
    renameGroup,
    saveTabs,
    removeTab,
    moveTab,
    createSession,
    getSessions,
    searchTabs,
    exportData,
    importData,
    getTotalTabCount,
    normalizeUrl,
    generateId,
  };
}
